\documentclass[a4paper, 12pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage{geometry}
\geometry{margin=2.5cm}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{enumitem}

\definecolor{codebg}{rgb}{0.95,0.95,0.95}
\definecolor{codegreen}{rgb}{0,0.5,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{codeblue}{rgb}{0.0,0.0,0.7}

\lstdefinestyle{haskellstyle}{
    backgroundcolor=\color{codebg},
    commentstyle=\color{codegreen},
    keywordstyle=\color{codeblue}\bfseries,
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\small,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    frame=single,
    language=Haskell,
    morekeywords={module, where, import, qualified, data, type, newtype, deriving, instance, case, of, let, in, if, then, else, do, return, class},
    literate={á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1 {ñ}{{\~n}}1 {→}{{$\rightarrow$}}1
}

\lstdefinestyle{finstyle}{
    backgroundcolor=\color{codebg},
    commentstyle=\color{codegreen},
    keywordstyle=\color{codeblue}\bfseries,
    basicstyle=\ttfamily\small,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    frame=single,
    morekeywords={let, zero, one, give, and, or, truncate, then, scale, if, else, deposit, propose, sign, execute, setfecha, balance},
    morecomment=[l]{--},
    literate={á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1 {ñ}{{\~n}}1 {→}{{$\rightarrow$}}1
}

\lstdefinestyle{replstyle}{
    backgroundcolor=\color{codebg},
    basicstyle=\ttfamily\small,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    frame=single,
    literate={á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1 {ñ}{{\~n}}1 {→}{{$\rightarrow$}}1
}

\lstset{style=haskellstyle}

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    urlcolor=blue,
    citecolor=blue
}

\begin{document}

\begin{titlepage}
    \centering
    \vspace*{2cm}
    
    {\Large \textbf{Universidad Nacional de Rosario}}\\[0.3cm]
    {\large Facultad de Ciencias Exactas, Ingeniería y Agrimensura}\\[2cm]
    \begin{figure}[h]

    \centering

    % Asegúrate de tener el archivo Logo-Unr-1.png en la misma carpeta

    \includegraphics[width=0.4\linewidth]{Logo-Unr-1.png} 

    \end{figure}
    {\large \textbf{Análisis de Lenguajes de Programación}}\\[0.2cm]
    {\large R-322}\\[2cm]
    
    {\Large \textbf{Informe Trabajo Práctico Final}}\\[0.5cm]
    {\LARGE \textbf{EDSL de Contratos Financieros en Haskell}}\\[3cm]
    
    {\large \textbf{Alumno}}\\[0.2cm]
    {\large Bussanich, Santiago --- Legajo: 6488/2}\\[3cm]
    
    {\large 26 de Febrero, 2026}
    
    \vfill
\end{titlepage}

\tableofcontents
\newpage

% ═══════════════════════════════════════════════════════════════════════════════
\section{Descripción del proyecto}
% ═══════════════════════════════════════════════════════════════════════════════

\subsection{Introducción}

\subsubsection{Contratos financieros}

Un contrato financiero es un acuerdo legal entre dos o más partes que establece obligaciones y derechos sobre flujos de dinero futuros. Estos contratos son fundamentales en los mercados financieros y abarcan instrumentos como bonos, préstamos, swaps de monedas, opciones y derivados.

La diversidad y complejidad de los contratos financieros los convierte en un dominio ideal para ser modelado mediante lenguajes formales. De manera análoga a como los lenguajes de programación permiten describir computaciones, un lenguaje de contratos financieros permite describir de forma precisa y composicional las obligaciones monetarias entre partes.

En su paper \textit{``Composing Contracts: An Adventure in Financial Engineering''} \cite{peytonjones2000}, Peyton Jones, Eber y Seward proponen modelar contratos financieros como un tipo de datos algebraico, donde contratos complejos se construyen a partir de combinadores simples. Los combinadores principales son:

\begin{itemize}
    \item \texttt{zero}: el contrato nulo, sin obligaciones para ninguna de las partes. Es el elemento neutro de la composición: \texttt{c and zero} es equivalente a \texttt{c}. Permite representar la ausencia de un acuerdo o la rama vacía de una elección.

    \item \texttt{one c}: el contrato más simple con contenido: la contraparte entrega inmediatamente una unidad de la moneda \texttt{c} al titular del contrato. Es el ``átomo'' a partir del cual se construyen todos los demás contratos con valor monetario.

    \item \texttt{give c}: invierte los roles de un contrato. Si \texttt{c} dice ``la contraparte me paga'', entonces \texttt{give c} dice ``yo le pago a la contraparte''. Aplicar \texttt{give} dos veces devuelve el contrato original. Esto permite modelar obligaciones bidireccionales: por ejemplo, un swap se expresa como \texttt{give one USD and one EUR}.

    \item \texttt{and c1 c2}: adquiere ambos contratos simultáneamente. Ambas obligaciones se ejecutan y sus flujos de caja se combinan.

    \item \texttt{or c1 c2}: otorga al titular el derecho de elegir entre \texttt{c1} y \texttt{c2}, seleccionando el más favorable. Este combinador es fundamental para modelar opciones financieras: una opción de compra (\textit{call}) puede expresarse como la elección entre ejercer el contrato o no hacer nada (\texttt{contrato or zero}).

    \item \texttt{then c1 c2}: ejecuta \texttt{c1}; si éste no produce ningún flujo de caja (por ejemplo, porque venció), utiliza \texttt{c2} como respaldo. Sirve para modelar contratos con fallback: ``intentar cobrar el bono; si expiró, ejecutar la garantía''.

    \item \texttt{scale o c}: multiplica todos los montos del contrato \texttt{c} por el valor del observable \texttt{o}. Es lo que permite pasar de ``una unidad de USD'' a ``1000 USD'' (con \texttt{scale 1000.0 one USD}), o vincular un contrato a un precio de mercado variable (con \texttt{scale OIL one USD}).

    \item \texttt{truncate d c}: limita la vigencia del contrato \texttt{c} hasta la fecha \texttt{d}. Si la fecha actual es posterior a \texttt{d}, el contrato no genera flujos de caja (se comporta como \texttt{zero}). Es importante notar que \texttt{truncate} no programa un pago para la fecha \texttt{d}, sino que establece un horizonte de vencimiento: el contrato es válido \textbf{hasta} esa fecha.
\end{itemize}

Este enfoque composicional permite construir contratos arbitrariamente complejos a partir de piezas simples, de la misma manera en que un programa se construye a partir de expresiones y sentencias.

\subsubsection{Observables}

Los observables representan valores que pueden variar en el tiempo y que son consultados durante la evaluación de un contrato. Típicamente se trata de precios de mercado, tasas de cambio, o índices financieros. La idea de éstos es que representen alguna cantidad que pueda ser medida objetivamente. Por ejemplo, el valor al que cotiza el dólar en Argentina hoy puede ser buscado y verificado por ambas partes, mientras que el valor subjetivo que una persona le asigna a su propiedad puede no serlo.

En nuestro lenguaje, los observables se utilizan dentro del constructor \texttt{scale} para determinar el factor de escala que se aplica a los flujos de caja generados por un contrato, y dentro de los condicionales \texttt{if} para tomar decisiones basadas en comparaciones numéricas.
Un observable puede ser una constante numérica (por ejemplo, \texttt{1000.0}), un valor externo que se obtiene de un oráculo (por ejemplo, \texttt{OIL} para el precio del petróleo), o una consulta de saldo de billetera (por ejemplo, \texttt{balance Alice USD}). Además, es posible combinar observables mediante operaciones aritméticas (\texttt{+}, \texttt{-}, \texttt{*}, \texttt{/}).

\subsection{Objetivo}

En este trabajo desarrollamos un \textbf{Embedded Domain Specific Language} (EDSL) implementado en Haskell para modelar, evaluar y simular contratos financieros. El lenguaje, al que llamamos \textit{Financial Contracts EDSL}, permite:

\begin{enumerate}[nosep]
    \item \textbf{Definir} contratos financieros de forma declarativa y composicional.
    \item \textbf{Parsear} descripciones de contratos a partir de texto, utilizando combinadores de Parsec.
    \item \textbf{Evaluar} contratos para generar flujos de caja (\textit{cashflows}) concretos.
    \item \textbf{Componer} contratos de forma modular usando los combinadores del paper.
    \item \textbf{Nombrar} contratos con \texttt{let} y reutilizarlos como variables.
    \item \textbf{Pretty-printing} contratos con paréntesis mínimos respetando precedencias.
    \item \textbf{Simular} la ejecución con billeteras, verificación de saldos y firmas duales.
    \item \textbf{Condicionar} contratos a observables booleanos con \texttt{if}/\texttt{else}.
    \item \textbf{Avanzar en el tiempo} con \texttt{setfecha}, observando la evolución temporal de las billeteras.
    \item \textbf{Exportar} resultados a reportes HTML con gráficos SVG embebidos, y diagramas de AST.
\end{enumerate}

El lenguaje se presenta con un REPL interactivo que permite definir, componer, evaluar y visualizar contratos financieros de forma inmediata. Se trata de una implementación del paper de Peyton Jones et al., con simplificaciones en la evaluación de \texttt{or} y \texttt{then}, y extensiones significativas en cuanto a billeteras, firmas, condicionales, exportación y visualización.

% ═══════════════════════════════════════════════════════════════════════════════
\section{El lenguaje}
% ═══════════════════════════════════════════════════════════════════════════════

\subsection{Sintaxis abstracta}

La sintaxis abstracta del lenguaje se divide en cuatro categorías principales: contratos, observables numéricos, observables booleanos y comandos.

\begin{center}
\begin{tabular}{r c l}
\textit{contract} & ::= & \texttt{zero} \\
    & $|$ & \texttt{one} \textit{currency} \\
    & $|$ & \texttt{give} \textit{contract} \\
    & $|$ & \textit{contract} \texttt{and} \textit{contract} \\
    & $|$ & \textit{contract} \texttt{or} \textit{contract} \\
    & $|$ & \textit{contract} \texttt{then} \textit{contract} \\
    & $|$ & \texttt{scale} \textit{obs} \textit{contract} \\
    & $|$ & \texttt{truncate} \textit{date} \textit{contract} \\
    & $|$ & \texttt{if} \textit{obsBool} \texttt{then} \textit{contract} \texttt{else} \textit{contract} \\
    & $|$ & \textit{variable} \\[10pt]
\textit{obs} & ::= & \textit{number} \\
    & $|$ & \textit{identifier} \\
    & $|$ & \texttt{balance} \textit{party} \textit{currency} \\
    & $|$ & \textit{obs} \texttt{+} \textit{obs} \\
    & $|$ & \textit{obs} \texttt{-} \textit{obs} \\
    & $|$ & \textit{obs} \texttt{*} \textit{obs} \\
    & $|$ & \textit{obs} \texttt{/} \textit{obs} \\
    & $|$ & \texttt{-} \textit{obs} \\[10pt]
\textit{obsBool} & ::= & \textit{obs} \texttt{>} \textit{obs} \\
    & $|$ & \textit{obs} \texttt{<} \textit{obs} \\
    & $|$ & \textit{obs} \texttt{>=} \textit{obs} \\
    & $|$ & \textit{obs} \texttt{<=} \textit{obs} \\
    & $|$ & \textit{obs} \texttt{==} \textit{obs} \\[10pt]
\textit{comm} & ::= & \texttt{let} \textit{variable} \texttt{=} \textit{contract} \\
    & $|$ & \textit{comm} \texttt{;} \textit{comm} \\
    & $|$ & \textit{contract} \\
    & $|$ & \texttt{deposit} \textit{party} \textit{amount} \textit{currency} \\
    & $|$ & \texttt{propose} \textit{name} \textit{contract} \\
    & $|$ & \texttt{sign} \textit{name} \textit{party} \\
    & $|$ & \texttt{execute} \textit{name} \\
    & $|$ & \texttt{setfecha} \textit{date} \\[10pt]
\textit{currency} & ::= & \texttt{USD} $|$ \texttt{EUR} $|$ \texttt{ARS} $|$ \texttt{GBP} \\[5pt]
\textit{date} & ::= & \texttt{YYYY-MM-DD} \\
\end{tabular}
\end{center}

\subsection{Sintaxis concreta}

La sintaxis concreta sigue la gramática de precedencias implementada en el parser.

\begin{center}
\begin{tabular}{r c l}
\textit{digit} & ::= & \texttt{'0'} $|$ \texttt{'1'} $|$ $\cdots$ $|$ \texttt{'9'} \\
\textit{nat} & ::= & \textit{digit} $|$ \textit{digit nat} \\
\textit{float} & ::= & \textit{nat} \texttt{'.'} \textit{nat} \\
\textit{identifier} & ::= & \textit{letter} \textit{rest} \\
\textit{rest} & ::= & \textit{letter} \textit{rest} $|$ \textit{digit} \textit{rest} $|$ $\epsilon$ \\[10pt]

\textit{comm} & ::= & \textit{singleComm}  \texttt{';'} \textit{comm} $|$ \textit{singleComm} \\
\textit{singleComm} & ::= & \textit{assign} $|$ \textit{deposit} $|$ \textit{propose} $|$ \textit{sign} $|$ \textit{execute} $|$ \textit{setfecha} $|$ \textit{evalComm} \\
\textit{assign} & ::= & \texttt{'let'} \textit{identifier} \texttt{'='} \textit{contract} \\
\textit{deposit} & ::= & \texttt{'deposit'} \textit{identifier} \textit{number} \textit{currency} \\
\textit{propose} & ::= & \texttt{'propose'} \textit{identifier} \textit{contract} \\
\textit{sign} & ::= & \texttt{'sign'} \textit{identifier} \textit{identifier} \\
\textit{execute} & ::= & \texttt{'execute'} \textit{identifier} \\
\textit{setfecha} & ::= & \texttt{'setfecha'} \textit{date} \\
\textit{evalComm} & ::= & \textit{contract} \\[10pt]

\textit{contract} & ::= & \textit{term} \texttt{'or'} \textit{contract} $|$ \textit{term} \\
\textit{term} & ::= & \textit{factor}  \texttt{'and'} \textit{term} $|$ \textit{factor} \\
\textit{factor} & ::= & \textit{prefix}  \texttt{'then'} \textit{factor} $|$ \textit{prefix} \\
\textit{prefix} & ::= & \texttt{'give'} \textit{prefix} \\
    & $|$ & \texttt{'scale'} \textit{observable} \textit{prefix} \\
    & $|$ & \texttt{'truncate'} \textit{date} \textit{prefix} \\
    & $|$ & \texttt{'if'} \textit{obsBool} \texttt{'then'} \textit{prefix} \texttt{'else'} \textit{prefix} \\
    & $|$ & \textit{atom} \\
\textit{atom} & ::= & \texttt{'('} \textit{contract} \texttt{')'} $|$ \texttt{'zero'} $|$ \texttt{'one'} \textit{currency} $|$ \textit{identifier} \\[10pt]

\textit{obsBool} & ::= & \textit{observable} \textit{boolOp} \textit{observable} \\
\textit{boolOp} & ::= & \texttt{'>'} $|$ \texttt{'<'} $|$ \texttt{'>='} $|$ \texttt{'<='} $|$ \texttt{'=='} \\[10pt]

\textit{observable} & ::= & \textit{obsTerm} \texttt{'+'} \textit{obsTerm} $|$ \textit{obsTerm} \texttt{'-'} \textit{obsTerm} $|$ \textit{obsTerm}\\
\textit{obsTerm} & ::= & \textit{obsAtom} \texttt{'*'} \textit{obsAtom} $|$ \textit{obsAtom} \texttt{'/'} \textit{obsAtom} $|$ \textit{obsAtom} \\
\textit{obsAtom} & ::= & \texttt{'('} \textit{observable} \texttt{')'} $|$ \texttt{'-'} \textit{obsAtom} $|$ \textit{float} $|$ \textit{nat} \\
    & $|$ & \texttt{'balance'} \textit{identifier} \textit{currency} $|$ \textit{identifier} \\[10pt]

\textit{date} & ::= & \textit{digit}$^4$ \texttt{'-'} \textit{digit}$^2$ \texttt{'-'} \textit{digit}$^2$ \\
\textit{currency} & ::= & \texttt{'USD'} $|$ \texttt{'EUR'} $|$ \texttt{'ARS'} $|$ \texttt{'GBP'} \\
\end{tabular}
\end{center}

\subsection{Ejemplos}

Para comprender mejor la semántica del lenguaje, veamos algunos ejemplos concretos. El contrato financiero más básico que podemos expresar es un \textit{zero-coupon bond}: un instrumento que promete un pago fijo en una fecha futura.

\begin{lstlisting}[style=finstyle, caption={Zero-coupon bond (basico.fin)}]
-- Un zero-coupon bond: recibir 1000 USD antes del 2027-01-01
let pago = one USD;
let bono = scale 1000.0 pago;
let zcb = truncate 2027-01-01 bono;
zcb
\end{lstlisting}

Este programa define un contrato que genera un pago de 1000 USD con vencimiento al 1 de enero de 2027. Podemos observar varias características del lenguaje: la definición de contratos con \texttt{let}, la composición mediante \texttt{scale} y \texttt{truncate}, y la evaluación final al escribir simplemente el nombre del contrato.

Un ejemplo más interesante es un \textit{currency swap}, donde una parte paga en una moneda y recibe en otra:

\begin{lstlisting}[style=finstyle, caption={Currency swap (swap.fin)}]
-- Un currency swap: yo pago USD y recibo EUR
let pagoUSD = give one USD;
let cobroEUR = one EUR;
let swap = pagoUSD and cobroEUR;
scale 1000.0 swap
\end{lstlisting}

Aquí utilizamos \texttt{give} para invertir la dirección del pago y \texttt{and} para combinar ambas obligaciones. Finalmente, \texttt{scale 1000.0} amplifica los montos a cantidades significativas.

Un ejemplo que combina billeteras, firmas y evolución temporal:

\begin{lstlisting}[style=finstyle, caption={Evolución temporal con billeteras (graficoTemporal.fin)}]
setfecha 2026-01-01;
deposit Bussa 10000 USD;
deposit Banco 5000 USD;

setfecha 2026-06-01;
propose pago1 give scale 3000.0 one USD;
sign pago1 Bussa; sign pago1 Banco; execute pago1;

setfecha 2026-12-01;
propose pago2 give scale 2000.0 one USD;
sign pago2 Bussa; sign pago2 Banco; execute pago2
\end{lstlisting}

Este ejemplo muestra el flujo completo de simulación: se fija una fecha inicial, se depositan fondos en las billeteras, se avanza en el tiempo, se proponen contratos, ambas partes firman, y se ejecutan. Al exportar un reporte HTML, se genera una tabla de eventos y un gráfico SVG que muestra la evolución de los saldos a lo largo del tiempo.

Finalmente, un ejemplo con condicionales:

\begin{lstlisting}[style=finstyle, caption={Opción call condicional (opcion\_call.fin)}]
-- Derecho a comprar acciones de AAPL al precio actual
let compra = scale AAPL one USD;
-- or zero: si el contrato no conviene, no se ejerce
let call = compra or zero;
call
\end{lstlisting}

% ═══════════════════════════════════════════════════════════════════════════════
\section{Manual de uso e instalación}
% ═══════════════════════════════════════════════════════════════════════════════

\subsection{Compilación}

Para compilar el proyecto, debemos ejecutar el comando

\begin{lstlisting}[style=replstyle, numbers=none]
stack build
\end{lstlisting}

desde el directorio raíz del proyecto. Esto descargará las dependencias necesarias (Parsec, Haskeline, mtl, etc.) y compilará el intérprete.

\subsection{Ejecución del REPL}

Una vez compilado, podemos iniciar el REPL interactivo con:

\begin{lstlisting}[style=replstyle, numbers=none]
stack run
\end{lstlisting}

Esto nos presenta el intérprete con el prompt \texttt{Fin>}, donde podemos escribir contratos, comandos y utilizar las directivas del sistema.

\subsection{Uso del REPL}

\begin{lstlisting}[style=replstyle, numbers=none, caption={Sesión de ejemplo en el REPL}]
Interprete de EDSL de Contratos Financieros.
Escriba :? para recibir ayuda.
Fin> one USD
Fecha        Monto          Desde -> Hacia
-----------------------------------------
2026-02-26  1 USD  Bob -> Alice

Fin> let swap = give one USD and one EUR
Contrato(s) asignado(s) correctamente.

Fin> scale 1000.0 swap
Fecha        Monto          Desde -> Hacia
-----------------------------------------
2026-02-26  1000 USD  Alice -> Bob
2026-02-26  1000 EUR  Bob -> Alice

Fin> deposit Alice 5000 USD
Contrato(s) asignado(s) correctamente.

Fin> :w Alice
  [Alice]
  ------------------------------
    USD   5000

Fin> :l Ejemplos/basico.fin
Archivo Ejemplos/basico.fin cargado correctamente.
Fecha        Monto          Desde -> Hacia
-----------------------------------------
2026-02-26  1000 USD  Bob -> Alice

Fin> :r reporte.html
Reporte exportado a reporte.html

Fin> :q
Saliendo del interprete financiero.
\end{lstlisting}

\subsection{Comandos disponibles}

Los comandos se dividen en dos categorías: comandos del \textbf{lenguaje} (que se escriben directamente sin prefijo) y comandos del \textbf{REPL} (prefijados con \texttt{:}).

\subsubsection{Comandos del lenguaje}

\begin{center}
\begin{tabular}{l l}
\toprule
\textbf{Comando} & \textbf{Descripción} \\
\midrule
\texttt{<contrato>} & Evaluar un contrato y mostrar cashflows \\
\texttt{let x = <contrato>} & Asignar un alias a un contrato \\
\texttt{c1 ; c2} & Secuenciar comandos \\
\texttt{deposit <parte> <monto> <moneda>} & Depositar fondos en una billetera \\
\texttt{propose <nombre> <contrato>} & Proponer contrato (requiere firmas) \\
\texttt{sign <nombre> <parte>} & Firmar un contrato pendiente \\
\texttt{execute <nombre>} & Ejecutar contrato firmado \\
\texttt{setfecha YYYY-MM-DD} & Cambiar fecha de evaluación \\
\texttt{if <cond> then <c> else <c>} & Condicional sobre observables \\
\bottomrule
\end{tabular}
\end{center}

\subsubsection{Comandos del REPL}

Cada comando del REPL tiene un alias corto que permite invocarlo más rápidamente. La resolución de comandos prioriza coincidencias exactas contra los alias antes de buscar por prefijo, lo que evita ambigüedades.

\begin{center}
\begin{tabular}{l l l}
\toprule
\textbf{Comando} & \textbf{Alias} & \textbf{Descripción} \\
\midrule
\texttt{:ast <exp>} & \texttt{:a} & Mostrar el AST de un contrato \\
\texttt{:pp <exp>} & & Pretty print de un contrato \\
\texttt{:eval <exp>} & \texttt{:e} & Evaluar un contrato directamente \\
\texttt{:load <archivo>} & \texttt{:l} & Cargar un archivo \texttt{.fin} \\
\texttt{:store} & \texttt{:s} & Mostrar contratos definidos \\
\texttt{:quote [<nombre> <val>]} & \texttt{:qt} & Ver/definir cotización del oráculo \\
\texttt{:partes [<yo> <contra>]} & \texttt{:p} & Ver/cambiar las partes del contrato \\
\texttt{:wallet [<parte>]} & \texttt{:w} & Ver billetera(s) \\
\texttt{:pending} & \texttt{:pd} & Ver contratos pendientes de firma \\
\texttt{:setfecha <YYYY-MM-DD>} & \texttt{:sf} & Cambiar fecha de evaluación \\
\texttt{:historial} & \texttt{:hi} & Ver historial de ejecuciones \\
\texttt{:reporte [<archivo.html>]} & \texttt{:r} & Exportar reporte HTML completo \\
\texttt{:ast-svg <contrato> > <archivo>} & \texttt{:svg} & Exportar AST del contrato a SVG \\
\texttt{:quit} & \texttt{:q} & Salir del intérprete \\
\texttt{:help} o \texttt{:?} & \texttt{:h} & Mostrar ayuda \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Archivos \texttt{.fin}}

Es posible escribir programas en archivos con extensión \texttt{.fin} y cargarlos desde el REPL con \texttt{:load}. El directorio \texttt{Ejemplos/} contiene 15 archivos de ejemplo que cubren distintos escenarios financieros. La sintaxis de estos archivos sigue las siguientes convenciones:

\begin{itemize}[nosep]
    \item Los comentarios se escriben con \texttt{-{}-} al inicio de la línea.
    \item Las líneas vacías se ignoran.
    \item Los comandos se separan explícitamente con \texttt{;}.
    \item La última expresión (la evaluación) no lleva \texttt{;} al final.
\end{itemize}

% ═══════════════════════════════════════════════════════════════════════════════
\section{Organización de los archivos}
% ═══════════════════════════════════════════════════════════════════════════════

El trabajo se encuentra dividido en los siguientes directorios principales:

\textbf{src/.} Contiene el código fuente principal del lenguaje:
\begin{itemize}[nosep]
    \item \textbf{AST.hs.} Define los tipos de datos algebraicos del lenguaje: \texttt{Contract}, \texttt{Obs}, \texttt{ObsBool}, \texttt{Comm} y \texttt{PendingContract}.
    \item \textbf{Types.hs.} Define los tipos base: \texttt{Currency}, \texttt{Amount}, \texttt{Cashflow}, \texttt{Env}, \texttt{Wallets}, \texttt{HistorialEntry}, \texttt{WalletSnapshot} y \texttt{EvalError}.
    \item \textbf{Monads.hs.} Define la mónada \texttt{Interp} (un stack de \texttt{StateT}, \texttt{ReaderT}, \texttt{WriterT} y \texttt{Either} de \texttt{mtl}) junto con el estado mutable \texttt{InterpState} y las funciones de acceso.
    \item \textbf{Parser.hs.} Implementa el parser del lenguaje utilizando Parsec, con gramática de precedencias para contratos, observables numéricos, observables booleanos y todos los comandos.
    \item \textbf{Evaluator.hs.} Implementa el evaluador de contratos, observables, observables booleanos y comandos (incluyendo \texttt{deposit}, \texttt{propose}, \texttt{sign}, \texttt{execute}, \texttt{setfecha}), además de las operaciones de billetera.
    \item \textbf{PrettyPrinter.hs.} Pretty printer con niveles de precedencia, formateo de cashflows, billeteras, historial, pendientes y errores.
    \item \textbf{Exportar.hs.} Genera reportes HTML autocontenidos con gráficos SVG embebidos (incluyendo barras de cashflows y gráficos de evolución temporal de billeteras).
    \item \textbf{ExportarAST.hs.} Genera diagramas de árbol SVG del AST de contratos, incluyendo el layout jerárquico con posicionamiento automático de nodos y coloreado por tipo de combinador.
\end{itemize}

\textbf{app/.} Contiene un único archivo, \texttt{Main.hs}, donde se encuentra el REPL interactivo construido con Haskeline. En este archivo se definen los comandos del intérprete, el manejo de estado (\texttt{InterpState} + \texttt{Env}), la carga de archivos \texttt{.fin}, y la interfaz de usuario.

\textbf{Ejemplos/.} Es el directorio donde se almacenan los 15 archivos de ejemplo \texttt{.fin} que cubren escenarios como bonos, swaps, opciones, derivados, coberturas, préstamos y evolución temporal.

\textbf{Exports/.} Contiene ejemplos pre-generados de las salidas del sistema: reportes HTML completos (\texttt{reporte\_completo.html}, \texttt{reporte\_empresa.html}, \texttt{reporte\_temporal.html}) y diagramas SVG de árboles AST (\texttt{ast\_bono.svg}, \texttt{ast\_collar.svg}, \texttt{ast\_opcion.svg}, etc.). Estos archivos permiten visualizar las capacidades del sistema sin necesidad de compilarlo.

Los demás archivos y directorios que pueden encontrarse en el directorio raíz (\texttt{stack.yaml}, \texttt{package.yaml}, \texttt{.stack-work/}, etc.) son generados y utilizados por la herramienta Stack.

% ═══════════════════════════════════════════════════════════════════════════════
\section{Decisiones de diseño y observaciones}
% ═══════════════════════════════════════════════════════════════════════════════

\subsection{El AST}

Los tipos de datos del lenguaje están definidos en \texttt{AST.hs} como tipos algebraicos de Haskell siguiendo un enfoque de \textbf{deep embedding}: los contratos se representan como un árbol de sintaxis abstracta (AST) que puede ser inspeccionado, transformado y evaluado. A diferencia de un \textit{shallow embedding}, donde cada combinador se definiría directamente como una función Haskell que computa su resultado, el deep embedding nos permite operar sobre la \textit{estructura} del contrato. Esto es lo que hace posible, por ejemplo, hacer pretty printing, sustituir variables, detectar ciclos, exportar diagramas SVG del AST, y potencialmente aplicar optimizaciones o transformaciones sobre contratos antes de evaluarlos.

El tipo principal \texttt{Contract} representa los combinadores del paper, extendidos con condicionales:

\begin{lstlisting}[caption={Tipo de datos Contract (AST.hs)}]
data Contract
  = Zero
  | One Currency
  | Give Contract
  | And Contract Contract
  | Or  Contract Contract
  | Truncate Date Contract
  | Then Contract Contract
  | Scale (Obs Double) Contract
  | Var String
  | If ObsBool Contract Contract
  deriving (Show, Eq)
\end{lstlisting}

El constructor \texttt{Var String} no forma parte del paper original, sino que fue añadido para soportar el sistema de variables (aliasing). Cuando el usuario escribe \texttt{let swap = give one USD and one EUR}, el parser genera un \texttt{Assign "swap" (And (Give (One USD)) (One EUR))}, y posteriores referencias a \texttt{swap} se parsean como \texttt{Var "swap"}.

El constructor \texttt{If ObsBool Contract Contract} permite condicionar la elección de contrato en base a comparaciones numéricas de observables. Por ejemplo, \texttt{if OIL > 100.0 then scale OIL one USD else zero} evalúa un contrato u otro según el precio del petróleo.

Los observables booleanos se definen como un tipo separado para mantener la separación de tipos limpia:

\begin{lstlisting}[caption={Tipo de datos ObsBool (AST.hs)}]
data ObsBool
  = Gt  (Obs Double) (Obs Double)   -- obs > obs
  | Lt  (Obs Double) (Obs Double)   -- obs < obs
  | Gte (Obs Double) (Obs Double)   -- obs >= obs
  | Lte (Obs Double) (Obs Double)   -- obs <= obs
  | Eq  (Obs Double) (Obs Double)   -- obs == obs
  deriving (Show, Eq)
\end{lstlisting}

Los comandos se representan con el tipo \texttt{Comm}, que incluye todos los comandos del lenguaje:

\begin{lstlisting}[caption={Tipo de datos Comm (AST.hs)}]
data Comm
  = Assign  String Contract
  | Seq     Comm Comm
  | Run     Contract
  | Deposit PartyId Currency Double
  | Propose String Contract
  | Sign    String PartyId
  | Execute String
  | SetFecha Date
  deriving (Show, Eq)
\end{lstlisting}

Finalmente, los observables numéricos se representan como un tipo paramétrico, extendidos con un constructor \texttt{Balance} para consultar saldos de billetera:

\begin{lstlisting}[caption={Tipo de datos Obs (AST.hs)}]
data Obs a
  = Konst    a
  | Add      (Obs a) (Obs a)
  | Sub      (Obs a) (Obs a)
  | Mul      (Obs a) (Obs a)
  | Div      (Obs a) (Obs a)
  | Neg      (Obs a)
  | External String
  | Balance  PartyId Currency
  deriving (Show, Eq, Read)
\end{lstlisting}

El constructor \texttt{Balance PartyId Currency} permite que un contrato consulte dinámicamente el saldo de una parte en una moneda determinada. Esto habilita contratos como ``si Alice tiene más de 1000 USD, entonces pagar 500 EUR''.

Hemos implementado las instancias de \texttt{Num} y \texttt{Fractional} para \texttt{Obs a}, lo cual permite escribir expresiones aritméticas directamente sobre observables utilizando la sintaxis natural de Haskell a nivel de la implementación.

\subsection{Parsing}

Para el parseo utilizamos la librería Parsec \cite{parsec}, que ya habíamos utilizado en otros trabajos de la materia. La sintaxis del lenguaje es relativamente simple y alternativas como Happy resultaban innecesariamente complejas para nuestro alcance.

La gramática de contratos se implementó con una jerarquía de precedencias para resolver la ambigüedad de los operadores infijos:

\begin{center}
\begin{tabular}{c l l}
\toprule
\textbf{Precedencia} & \textbf{Operador} & \textbf{Asociatividad} \\
\midrule
0 (más baja) & \texttt{or} & izquierda \\
1 & \texttt{and} & izquierda \\
2 & \texttt{then} & izquierda \\
3 & prefijos (\texttt{give}, \texttt{scale}, \texttt{truncate}, \texttt{if}) & --- \\
4 (más alta) & átomos (\texttt{zero}, \texttt{one}, variables, paréntesis) & --- \\
\bottomrule
\end{tabular}
\end{center}

Esta jerarquía se implementa con funciones mutuamente recursivas utilizando \texttt{chainl1} de Parsec:

\begin{lstlisting}[caption={Jerarquía de precedencias en el parser}]
parserContract :: Parser Contract
parserContract = chainl1 parserTerm
                   (reserved "or" >> return Or)

parserTerm :: Parser Contract
parserTerm = chainl1 parserFactor
               (reserved "and" >> return And)

parserFactor :: Parser Contract
parserFactor = chainl1 parserPrefix
                 (reserved "then" >> return Then)
\end{lstlisting}

De manera similar, los observables tienen su propia jerarquía: suma/resta en el nivel más bajo, multiplicación/división en el nivel intermedio, y átomos (constantes, externos, balance, paréntesis) en el nivel más alto.

El parser de comandos usa \texttt{try} para intentar cada tipo de comando en orden, dándole prioridad a los que comienzan con palabras reservadas (\texttt{let}, \texttt{deposit}, \texttt{propose}, etc.) antes de intentar parsear un contrato como evaluación directa.

\subsection{La mónada Interp}

La mónada de evaluación se construye como un stack de transformadores de mónadas de la librería \texttt{mtl}:

\begin{lstlisting}[caption={Definición de la mónada Interp (Monads.hs)}]
type Interp = StateT InterpState
               (ReaderT Env
                 (WriterT [Cashflow]
                   (Either EvalError)))
\end{lstlisting}

Esta mónada combina cuatro efectos:

\begin{itemize}
    \item \textbf{State} (\texttt{InterpState}): estado mutable que contiene el store de contratos, las billeteras, los contratos pendientes, las cotizaciones del oráculo, el historial de ejecuciones, los snapshots temporales y la fecha actual.
    \item \textbf{Reader} (\texttt{Env}): acceso de solo lectura al entorno de evaluación, que contiene la función oráculo y las identidades de las partes del contrato.
    \item \textbf{Writer} (\texttt{[Cashflow]}): acumulación de flujos de caja generados durante la evaluación.
    \item \textbf{Either} (\texttt{EvalError}): manejo de errores (división por cero, observables desconocidos, saldo insuficiente, etc.).
\end{itemize}

El estado mutable \texttt{InterpState} agrupa toda la información que evoluciona durante la sesión:

\begin{lstlisting}[caption={Estado mutable del intérprete (Monads.hs)}]
data InterpState = InterpState
  { isContracts :: ContractStore
  , isWallets   :: Wallets
  , isPending   :: PendingStore
  , isQuotes    :: Map String Double
  , isHistorial :: [HistorialEntry]
  , isSnapshots :: [WalletSnapshot]
  , isFechaHoy  :: Date
  } deriving (Show)
\end{lstlisting}

Las funciones de acceso (\texttt{getContracts}, \texttt{putWallets}, \texttt{appendHistorial}, \texttt{appendSnapshot}, etc.) se definen como operaciones monádicas simples sobre este estado.

\subsection{El evaluador}

El evaluador se divide en cuatro funciones principales:

\textbf{\texttt{evalContract}.} Evalúa un contrato dentro de la mónada \texttt{Interp}, generando cashflows. Los casos más interesantes son:

\begin{itemize}
    \item \texttt{Give}: utiliza \texttt{localEnv} para intercambiar \texttt{yo} y \texttt{contraparte} en el entorno, invirtiendo la dirección de los pagos.
    \item \texttt{Or}: evalúa ambas ramas y elige la que maximiza el valor neto para la parte ``yo'', convirtiendo montos a USD mediante el oráculo para comparar. Si una rama falla y la otra no, se elige la exitosa.
    \item \texttt{Then}: evalúa la primera rama; si no genera cashflows, pasa a la segunda (mecanismo de fallback).
    \item \texttt{Scale}: evalúa el observable, y usa \texttt{censorFlows} para multiplicar los montos de todos los cashflows por el factor obtenido.
    \item \texttt{Truncate}: usa \texttt{censorFlows} para filtrar los cashflows cuya fecha exceda el límite.
    \item \texttt{If}: evalúa el observable booleano y, según el resultado, evalúa la rama verdadera o la falsa.
\end{itemize}

\textbf{\texttt{evalObs}.} Evalúa un observable numérico. Soporta constantes, valores externos (obtenidos mediante la función oráculo del entorno), consultas de \texttt{Balance} al estado de billeteras, y las cuatro operaciones aritméticas. La división por cero y el uso de observables no definidos en el oráculo se detectan y reportan como error.

\textbf{\texttt{evalBool}.} Evalúa un observable booleano comparando dos observables numéricos con los operadores \texttt{>}, \texttt{<}, \texttt{>=}, \texttt{<=} o \texttt{==}.

\textbf{\texttt{evalComm}.} Evalúa un comando, actualizando el \texttt{InterpState}. Los comandos se manejan así:
\begin{itemize}[nosep]
    \item \texttt{Assign}: almacena el contrato en el store \textbf{sin resolver variables}; la resolución se difiere al momento de la evaluación.
    \item \texttt{Run}: resuelve las variables con \texttt{substContract} y evalúa el contrato.
    \item \texttt{Seq}: ejecuta secuencialmente, propagando el estado actualizado.
    \item \texttt{Deposit}: agrega fondos a la billetera de una parte y registra un snapshot temporal.
    \item \texttt{Propose}: crea un contrato pendiente de firma entre las partes actuales.
    \item \texttt{Sign}: registra la firma de una parte sobre un contrato pendiente.
    \item \texttt{Execute}: si el contrato está completamente firmado, resuelve y evalúa el contrato, aplica los cashflows a las billeteras (verificando saldos), y registra la ejecución en el historial.
    \item \texttt{SetFecha}: cambia la fecha de evaluación y registra un snapshot del estado actual de las billeteras.
\end{itemize}

\subsection{Sustitución de variables y detección de ciclos}

El sistema de variables se implementa mediante la función \texttt{substContract}, que recorre recursivamente el contrato y reemplaza cada \texttt{Var name} por el contrato correspondiente del \texttt{ContractStore}. Esta resolución se realiza \textbf{antes} de la evaluación (al ejecutar un \texttt{Run} o \texttt{Execute}), lo que permite mantener la mónada \texttt{Interp} simple.

Para evitar ciclos infinitos (por ejemplo, \texttt{let x = x} o cadenas indirectas como \texttt{let a = b; let b = a}), la función mantiene un \texttt{Set String} con las variables ya visitadas:

\begin{lstlisting}[caption={Detección de ciclos en substContract (Evaluator.hs)}]
substContract :: ContractStore -> Contract
              -> Either EvalError Contract
substContract store = go Set.empty
  where
    go visited (Var name)
        | Set.member name visited =
            Left (EvalMsg $
              "Referencia ciclica: " ++ name)
        | otherwise =
            case Map.lookup name store of
              Just c  ->
                go (Set.insert name visited) c
              Nothing ->
                Left (EvalMsg $
                  "Contrato no definido: " ++ name)
    go visited (Give c)    =
        Give <$> go visited c
    go visited (And c1 c2) =
        And <$> go visited c1 <*> go visited c2
    -- ... (analogamente para los demas)
\end{lstlisting}

Es importante notar que el comando \texttt{Assign} almacena el contrato tal cual, sin resolver variables. Esto permite que las definiciones sean ``lazy'': un contrato puede hacer referencia a variables que aún no fueron definidas al momento de la asignación, siempre que estén definidas cuando se evalúe.

\subsection{Sistema de billeteras y firmas}

\subsubsection{Billeteras}

Cada parte del contrato tiene una billetera representada como un \texttt{Map Currency Double}, que registra su saldo en cada moneda. El tipo global es:

\begin{lstlisting}[caption={Tipo de billeteras (Types.hs)}]
type Wallets = Map PartyId (Map Currency Double)
\end{lstlisting}

Las operaciones básicas son \texttt{walletDeposit} (agregar fondos), \texttt{walletWithdraw} (debitar con verificación de saldo) y \texttt{applyWalletCashflows} (aplicar una lista de flujos de caja a las billeteras, verificando que cada pagador tenga fondos suficientes). Si un pagador no tiene saldo suficiente, la operación falla con un mensaje de error indicando el faltante.

\subsubsection{Contratos pendientes y firmas}

Para ejecutar un contrato a través del sistema de billeteras, se requiere que ambas partes lo firmen explícitamente. El flujo es:

\begin{enumerate}[nosep]
    \item \texttt{propose <nombre> <contrato>}: propone un contrato entre las partes actuales. Se crea un \texttt{PendingContract} con ambas firmas en estado \texttt{Pending}.
    \item \texttt{sign <nombre> <parte>}: la parte indicada firma el contrato. Solo las partes involucradas pueden firmar.
    \item \texttt{execute <nombre>}: si ambas partes firmaron, el contrato se evalúa y los flujos de caja resultantes se aplican a las billeteras. Si el pagador no tiene fondos suficientes, la ejecución falla sin modificar las billeteras.
\end{enumerate}

El tipo \texttt{PendingContract} almacena el contrato, las partes, el estado de firma de cada una, y la fecha de creación:

\begin{lstlisting}[caption={Contrato pendiente (AST.hs)}]
data PendingContract = PendingContract
  { pcName      :: String
  , pcContract  :: Contract
  , pcPartyA    :: PartyId
  , pcPartyB    :: PartyId
  , pcSignA     :: SignatureStatus
  , pcSignB     :: SignatureStatus
  , pcCreatedAt :: Day
  } deriving (Show)
\end{lstlisting}

\begin{lstlisting}[style=replstyle, numbers=none, caption={Sesión con billeteras y firmas}]
Fin> :partes Alice Bob
Partes actualizadas: yo = Alice, contraparte = Bob

Fin> deposit Alice 5000 USD; deposit Bob 3000 EUR

Fin> propose miSwap
     scale 1000.0 (give one USD and one EUR)

Fin> sign miSwap Alice; sign miSwap Bob

Fin> execute miSwap
Fecha        Monto          Desde -> Hacia
-----------------------------------------
2026-02-26  1000 USD  Alice -> Bob
2026-02-26  1000 EUR  Bob -> Alice
Billeteras actualizadas:
  [Alice]
    USD   4000
    EUR   1000
  [Bob]
    USD   1000
    EUR   2000
\end{lstlisting}

\subsection{Evolución temporal y setfecha}

El comando \texttt{setfecha} permite cambiar la fecha de evaluación durante la sesión. Esto posibilita simular escenarios temporales: depositar fondos en una fecha, ejecutar contratos en otra, y observar cómo evolucionan las billeteras.

Cada vez que se ejecuta \texttt{setfecha}, \texttt{deposit} o \texttt{execute}, se registra un \texttt{WalletSnapshot} con la fecha, el estado de las billeteras y una descripción del evento:

\begin{lstlisting}[caption={Snapshot temporal (Types.hs)}]
data WalletSnapshot = WalletSnapshot
  { snapFecha   :: Day
  , snapWallets :: Wallets
  , snapEvento  :: String
  } deriving (Show, Eq, Generic)
\end{lstlisting}

Estos snapshots se utilizan al exportar el reporte HTML para generar gráficos SVG de evolución temporal: una tabla de eventos y un gráfico de líneas por moneda que muestra la evolución del saldo de cada parte a lo largo del tiempo.

\subsection{Oráculo configurable}

El entorno de evaluación incluye una función \texttt{getQuote :: String -> Maybe Double} que actúa como oráculo para los observables externos. En lugar de utilizar una función hardcodeada, el oráculo se construye a partir de un mapa de cotizaciones (\texttt{Map String Double}) almacenado en el estado del REPL:

\begin{lstlisting}[caption={Construcción del oráculo (Main.hs)}]
makeOracle :: Map String Double
           -> (String -> Maybe Double)
makeOracle quotes name = Map.lookup name quotes
\end{lstlisting}

El comando \texttt{:quote} permite consultar y modificar las cotizaciones en tiempo de ejecución. Al actualizar una cotización, se reconstruye la función oráculo y se actualiza el entorno. El REPL inicializa el oráculo con valores por defecto:

\begin{center}
\begin{tabular}{l r}
\toprule
\textbf{Observable} & \textbf{Valor} \\
\midrule
\texttt{OIL} & 80.5 \\
\texttt{AAPL} & 150.0 \\
\texttt{USD\_ARS} & 1000.0 \\
\texttt{EUR\_USD} & 1.08 \\
\texttt{GBP\_USD} & 1.27 \\
\texttt{ARS\_USD} & 0.001 \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Pretty printer}

El pretty printer utiliza niveles de precedencia para minimizar el uso de paréntesis. Cada operador tiene asociado un nivel de precedencia, y los paréntesis solo se insertan cuando el nivel de precedencia del contexto exterior es mayor al del operador actual.

\begin{center}
\begin{tabular}{c l}
\toprule
\textbf{Prec.} & \textbf{Contratos} \\
\midrule
0 & \texttt{or} \\
1 & \texttt{and} \\
2 & \texttt{then} \\
3 & prefijos (\texttt{give}, \texttt{scale}, \texttt{truncate}, \texttt{if}) \\
4 & átomos (\texttt{zero}, \texttt{one}, variables) \\
\bottomrule
\end{tabular}
\hspace{1cm}
\begin{tabular}{c l}
\toprule
\textbf{Prec.} & \textbf{Observables} \\
\midrule
0 & \texttt{+}, \texttt{-} \\
1 & \texttt{*}, \texttt{/} \\
2 & átomos (constantes, externos, balance) \\
\bottomrule
\end{tabular}
\end{center}

De esta manera, una expresión como \texttt{(one USD and give one EUR) or zero} se imprime como \texttt{one USD and give one EUR or zero}, omitiendo los paréntesis innecesarios gracias a que \texttt{and} tiene mayor precedencia que \texttt{or}.

\subsection{Exportación y visualización}

El sistema ofrece múltiples opciones de exportación y visualización:

\subsubsection{Reporte HTML}

El comando \texttt{:reporte} genera un archivo HTML autocontenido (sin dependencias externas) que incluye:

\begin{enumerate}[nosep]
    \item \textbf{Contratos definidos}: tabla con nombre y definición de cada contrato en el store.
    \item \textbf{Billeteras}: tarjetas con el saldo de cada parte por moneda, coloreado en verde (positivo) o rojo (negativo).
    \item \textbf{Historial de ejecuciones}: para cada ejecución, una tarjeta con los cashflows en tabla y un gráfico SVG de barras embebido inline.
    \item \textbf{Evolución temporal}: una tabla de eventos (depósitos, setfecha, ejecuciones) y un gráfico SVG de líneas por moneda, mostrando cómo evoluciona el saldo de cada parte a lo largo del tiempo. Los gráficos se generan con ejes compartidos, leyenda apilada y soporte para datos de un solo punto.
\end{enumerate}

Todo el CSS está inline en el HTML, lo que lo hace completamente portable.

\subsubsection{SVG del AST}

El comando \texttt{:ast-svg} genera un diagrama SVG\cite{svg} del árbol de sintaxis abstracta de un contrato. La generación se realiza en tres fases:

\begin{enumerate}[nosep]
    \item \textbf{Conversión a árbol de layout.} El tipo \texttt{Contract} se convierte a un árbol intermedio \texttt{ASTTree}, donde cada nodo almacena una etiqueta de texto y una lista de hijos. Los nodos hoja (\texttt{zero}, \texttt{one}, \texttt{Var}) no tienen hijos; los unarios (\texttt{give}, \texttt{scale}, \texttt{truncate}) tienen un hijo; y los binarios (\texttt{and}, \texttt{or}, \texttt{then}, \texttt{if}) tienen dos.
    \item \textbf{Cálculo de posiciones.} Se calcula recursivamente el ancho de cada subárbol como el máximo entre el ancho de un nodo individual (100px) y la suma de los anchos de sus hijos más los gaps de separación (20px). Luego, la función \texttt{layoutTree} asigna coordenadas $(x, y)$ a cada nodo: el padre se centra horizontalmente sobre el espacio ocupado por sus hijos, y los hijos se distribuyen uniformemente debajo usando \texttt{scanl} para calcular posiciones incrementales.
    \item \textbf{Renderizado.} Cada nodo se dibuja como un rectángulo redondeado (\texttt{<rect rx='6'>}) con texto centrado, y las conexiones padre-hijo como líneas (\texttt{<line>}). Las aristas se renderizan primero para que queden debajo de los nodos visualmente.
\end{enumerate}

Cada tipo de combinador tiene un color distintivo: azul (\texttt{and}), rojo (\texttt{give}), verde (\texttt{one}), naranja (\texttt{then}), púrpura (\texttt{or}), cyan (\texttt{scale}), verde oscuro (\texttt{truncate}), magenta (\texttt{if}) y gris (\texttt{zero}). Para nodos con información adicional (como el observable en \texttt{scale} o la fecha en \texttt{truncate}), la etiqueta se divide en dos líneas de texto SVG con fuentes de diferente tamaño.

El tamaño total del SVG se calcula dinámicamente a partir del ancho del árbol y su profundidad, garantizando que el diagrama se ajuste exactamente al contenido sin espacio desperdiciado.

\subsubsection{Gráfico de barras SVG}

Cada entrada del historial en el reporte HTML incluye un gráfico SVG\cite{svg} completo embebido inline, compuesto por tres secciones apiladas verticalmente:

\begin{enumerate}[nosep]
    \item \textbf{Tabla de cashflows.} Una tabla renderizada con primitivas SVG (\texttt{<text>} y \texttt{<rect>}) que muestra fecha, monto, origen y destino de cada flujo. Las filas alternan color de fondo para facilitar la lectura, y cada moneda se colorea con un color distintivo (azul para USD, naranja para EUR, púrpura para ARS, teal para GBP).
    \item \textbf{Barras horizontales.} Un gráfico de barras desde la perspectiva de una parte, donde el eje central (x=230) separa ingresos a la derecha (barras verdes) de egresos a la izquierda (barras rojas). El ancho de cada barra se normaliza linealmente respecto al valor absoluto máximo, lo que permite comparar visualmente magnitudes relativas.
    \item \textbf{Resumen neto por moneda.} Barras horizontales que muestran el saldo neto en cada moneda, con etiquetas que indican el signo y valor exacto. Utiliza colores por moneda en vez del esquema ingreso/egreso.
\end{enumerate}

La altura total del SVG se calcula dinámicamente como la suma de las tres secciones más márgenes, adaptándose al número de cashflows.

\subsubsection{Gráfico de evolución temporal}

Cuando existen snapshots temporales, el reporte HTML incluye una sección de evolución que genera un gráfico SVG\cite{svg} independiente por cada moneda utilizada en la sesión. Cada gráfico es un diagrama de líneas con las siguientes características:

\begin{itemize}[nosep]
    \item \textbf{Una línea por parte}: cada participante (por ejemplo, Alice, Bob) tiene una polilínea coloreada que muestra la evolución de su saldo en esa moneda a lo largo del tiempo.
    \item \textbf{Ejes compartidos}: el eje X muestra las fechas de los snapshots y el eje Y muestra los montos, con una grilla horizontal de referencia de 4 divisiones y etiquetas numéricas.
    \item \textbf{Línea de referencia en cero}: si el rango de valores incluye tanto positivos como negativos, se dibuja una línea punteada horizontal en $y = 0$ para facilitar la lectura.
    \item \textbf{Leyenda apilada}: en la esquina superior derecha, una leyenda vertical muestra el color asignado a cada parte, evitando solapamientos.
    \item \textbf{Soporte para punto único}: cuando hay un solo snapshot, en lugar de dibujar una polilínea (que sería invisible), se dibuja un único círculo en la posición correspondiente.
\end{itemize}

El rango del eje Y se calcula automáticamente a partir de los valores mínimos y máximos de todas las series; si todos los valores son iguales, se aplica un margen artificial del 10\% para evitar divisiones por cero en el escalado. Las coordenadas de pantalla se calculan con funciones \texttt{toX} y \texttt{toY} que mapean linealmente el dominio de fechas y valores al espacio de píxeles del gráfico.

Adicionalmente, se genera una tabla HTML de eventos que lista cronológicamente todos los depósitos, cambios de fecha y ejecuciones registrados durante la sesión.

\subsection{Evaluación con fecha mutable}

Una decisión de diseño significativa es el uso de una \textbf{fecha mutable} mediante el comando \texttt{setfecha}. La fecha se almacena en \texttt{InterpState} (campo \texttt{isFechaHoy}) y puede cambiar durante la sesión, lo que permite simular escenarios temporales. Esta fecha se lee en \texttt{evalContract} mediante \texttt{getFechaHoy} y afecta directamente a los combinadores \texttt{truncate} (que compara contra la fecha actual) y \texttt{one} (que asigna la fecha actual a los cashflows generados).

Esto permite escribir scripts como:

\begin{lstlisting}[style=finstyle, caption={Simulación temporal}, numbers=none]
setfecha 2026-01-01;
deposit Alice 10000 USD;
setfecha 2026-06-01;
execute pago1;
setfecha 2026-12-01;
execute pago2
\end{lstlisting}

donde cada ejecución ocurre en una fecha diferente, y los gráficos de evolución muestran correctamente la progresión temporal.

Sin embargo, el sistema sigue teniendo limitaciones respecto al paper original:

\begin{itemize}
    \item \textbf{Ausencia de \texttt{when}/\texttt{until}.} No hay mecanismo para ``esperar'' a que una condición se cumpla en el futuro. El condicional \texttt{if} evalúa la condición en el instante actual.
    \item \textbf{Semántica simplificada de \texttt{or}.} Elige por valor neto inmediato, sin considerar el valor temporal del dinero ni pagos futuros descontados.
    \item \textbf{Observables constantes por instante.} Cada observable tiene un valor fijo en cada momento (configurable vía \texttt{:quote}), sin simulación de caminos estocásticos.
    \item \textbf{\texttt{truncate} como horizonte.} Solo verifica si la fecha actual es anterior al límite; no programa pagos para fechas específicas.
\end{itemize}

Para extender el sistema con soporte temporal completo, sería necesario incorporar un modelo de evolución discreta del tiempo (retículos binomiales\cite{lattice} o simulaciones de Monte Carlo\cite{montecarlo}), observables dependientes del tiempo, y los combinadores \texttt{when} y \texttt{until} con su semántica de espera.

\subsection{El REPL}

El REPL se implementa con la librería Haskeline\cite{haskeline}, que proporciona edición de línea, historial, y autocompletado. El estado del REPL es una tupla \texttt{(InterpState, Env)}:

\begin{itemize}[nosep]
    \item \texttt{InterpState}: todo el estado mutable del lenguaje (contratos, billeteras, pendientes, cotizaciones, historial, snapshots, fecha).
    \item \texttt{Env}: el entorno de solo lectura (función oráculo, identidades de las partes).
\end{itemize}

Las identidades de las partes (\texttt{yo} y \texttt{contraparte}) son configurables en tiempo de ejecución mediante \texttt{:partes}. La fecha se actualiza tanto desde el lenguaje (\texttt{setfecha}) como desde el REPL (\texttt{:setfecha}), manteniéndose sincronizada entre \texttt{InterpState} y \texttt{Env}.

El sistema de comandos distingue entre directivas (prefijadas con \texttt{:}) y expresiones directas. Las expresiones se parsean como \texttt{Comm} y se evalúan con \texttt{evalComm} a través de la mónada \texttt{Interp}, mientras que las directivas realizan acciones especiales como exportar reportes, mostrar el AST, o modificar el oráculo.

Cada comando del REPL define uno o más alias (por ejemplo, \texttt{:q} para \texttt{:quit}, \texttt{:e} para \texttt{:eval}, \texttt{:l} para \texttt{:load}). La resolución de comandos utiliza un esquema de dos fases: primero se busca una coincidencia exacta contra los alias definidos, y solo si no se encuentra se recurre a coincidencia por prefijo (\texttt{isPrefixOf}). Este diseño evita ambigüedades; por ejemplo, \texttt{:q} resuelve exactamente a \texttt{:quit} sin confundirse con \texttt{:quote}, a pesar de que \texttt{:q} es prefijo de ambos.

% ═══════════════════════════════════════════════════════════════════════════════
\section{Bibliografía}
% ═══════════════════════════════════════════════════════════════════════════════

\begin{thebibliography}{9}

\bibitem{peytonjones2000}
S. Peyton Jones, J-M. Eber, J. Seward.
\textit{``Composing Contracts: An Adventure in Financial Engineering''}.
ICFP 2000.
\\\url{https://www.microsoft.com/en-us/research/publication/composing-contracts-an-adventure-in-financial-engineering/}

\bibitem{parsec}
Hackage. Documentación de Parsec.
\\\url{https://hackage.haskell.org/package/parsec}

\bibitem{haskeline}
Hackage. Documentación de Haskeline.
\\\url{https://hackage.haskell.org/package/haskeline}

\bibitem{containers}
Hackage. Documentación de Data.Map (containers).
\\\url{https://hackage.haskell.org/package/containers}

\bibitem{time}
Hackage. Documentación de Data.Time.
\\\url{https://hackage.haskell.org/package/time}

\bibitem{mtl}
Hackage. Documentación de mtl (Monad Transformer Library).
\\\url{https://hackage.haskell.org/package/mtl}

\bibitem{svg}
W3C. \textit{Scalable Vector Graphics (SVG) 2}.
W3C Candidate Recommendation, 2018.
\\\url{https://www.w3.org/TR/SVG2/}

\bibitem{lattice}
J. Cox, S. Ross, M. Rubinstein.
\textit{``Option Pricing: A Simplified Approach''}.
Journal of Financial Economics, 1979.
\\\url{https://en.wikipedia.org/wiki/Binomial_options_pricing_model}

\bibitem{montecarlo}
P. Boyle.
\textit{``Options: A Monte Carlo Approach''}.
Journal of Financial Economics, 1977.
\\\url{https://en.wikipedia.org/wiki/Monte_Carlo_methods_for_option_pricing}
\end{thebibliography}

\end{document}
